from itertools import groupby
from typing import Collection
from bauhaus import Encoding, proposition, constraint
from bauhaus.utils import count_solutions
import random
import pprint

# Encoding that will store all of your constraints
E = Encoding()

rows = 3
columns = 7
week = [[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]]
games = []
days = []
@proposition(E)
class game:
    def __init__(self,team1,team2):
        self.t1 = team1
        self.t2 = team2
    
    def team1(self):
        return self.t1
    def team2(self):
        return self.t2

    def __repr__(self) -> str:
        return f"games({self.t1}, {self.t2})"

@proposition(E)
class day:
    def __init__(self,g1,g2,g3,day_num):
        self.g1 = g1
        self.g2 = g2
        self.g3 = g3
        self.day_num = day_num
    
    def game1(self):
        return self.g1

    def game2(self):
        return self.g2

    def game3(self):
        return self.g3

    def day(self):
        return self.day_num

    def __repr__(self) -> str:
        return f"day({self.day_num, self.g1, self.g2, self.g3})"

for i in range(8):
    for j in range(8):
        if i != j:
            for k in range(4):
                games.append(game(i,j))
                
def no_same_team(g1, g2):
        if(isinstance(g1, int) or isinstance(g2, int)):
            return True
        elif(g1.team1() != g2.team1()& g1.team2() != g2.team1()& g1.team1() != g2.team2()& g1.team2() != g2.team2()):
            return True
        else:
            return False

def All_games_filled(day):
    if(day.game2() != None and day.game3() != None):
        teams = []
        teams.append(day.game1().team1())
        teams.append(day.game1().team2())
        teams.append(day.game2().team1())
        teams.append(day.game2().team2())
        teams.append(day.game3().team1())
        teams.append(day.game3().team2())
        if(len(teams) == len(set(teams))):
            return True
        else:
              return False  
    elif(day.game2() != None and day.game3() == None):
        teams = []
        teams.append(day.game1().team1())
        teams.append(day.game1().team2())
        teams.append(day.game2().team1())
        teams.append(day.game2().team2())
        if(len(teams) == len(set(teams))):
            return True
        else:
              return False  
    elif(day.game2() == None and day.game3() != None):
        teams = []
        teams.append(day.game1().team1())
        teams.append(day.game1().team2())
        teams.append(day.game3().team1())
        teams.append(day.game3().team2())
        if(len(teams) == len(set(teams))):
            return True
        else:
              return False  
    else:
        return True

def example_theory():
   

    #Put a game in each day
    for x in range(columns):
        selection = random.choice(games)
        week[0][x] = selection
        games.remove(selection)
    #get 7 more random games
    temp = []
    for x in range(columns):
        selection = random.choice(games)
        temp.append(selection)
        games.remove(selection)

    #place the 7 extra games
    while len(temp) != 0:
        print(temp[0])
        test = len(temp)
        for x in range(columns):
            if(isinstance(week[1][x], int) & no_same_team(temp[0], week[0][x])):
                print(1)
                week[1][x] = temp[0]
                temp.remove(temp[0])
                break
        if(len(temp) == test):
            for x in range(columns):
                if(isinstance(week[2][x], int) & no_same_team(temp[0], week[0][x])& no_same_team(temp[0], week[1][x])):
                  print(2)
                  week[2][x] = temp[0]
                  temp.remove(temp[0])
                  break
        if(len(temp) == test):
            for x in range(columns):
                if(isinstance(week[2][x], int)):
                  print(3)
                  week[2][x] = temp[0]
                  temp.remove(temp[0])
                  break
   
    
    #this constraint checks to make sure a team cannot play a game three days in a row
    for row in week:
        for column in week:
            for i in range(13):
                if (i%2==0):
                    if (column[i]==column[i+2]or column[i]==column[i+3]):
                        E.add_constraint(column [i]~ column [i+4] && column[i]~column[i+5])
                else:
                    if(column[i]==column[i+1] or column[i]==column[i+2]):
                        E.add_constraint(column[i]~column[i+3] && column[i]~column[i+4])


            
    #check if the days work
    current_day = 0
    for x in range(columns):
        if(isinstance(week[1][x], int)):
            if(isinstance(week[2][x], int)):
                days.append(day(week[0][x],None,None,current_day))
            else:
                days.append(day(week[0][x],None,week[2][x],current_day))
        elif(isinstance(week[2][x], int)):
            days.append(day(week[0][x],week[1][x],None,current_day))
        else:
            days.append(day(week[0][x],week[1][x],week[2][x],current_day))
        current_day += 1

    for d in days:
        if All_games_filled(d):
            E.add_constraint(d)
        else:
           E.add_constraint(~d)
        print(d)

    T = E.compile()
    return T
    

    

    
    


if __name__ == "__main__":

    T = example_theory()
    

    print("\nSatisfiable: %s" % T.satisfiable())
    print("# Solutions: %d" % count_solutions(T))
    print()
    print("   Solution: %s" % T.solve())

